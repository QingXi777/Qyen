<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Qyen Vision 登录 · 极光背景</title>
<link rel="preconnect" href="https://unpkg.com">
<script src="https://cdn.tailwindcss.com"></script>
<style>
  html,body{height:100%}
  body{
    margin:0; overflow:hidden; color:#fff;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:#05070a; /* 兜底色 */
  }

  /* 极光背景在底层 */
  #aurora-bg{ position:fixed; inset:0; z-index:0; }

  /* 登录表单始终居中，层级在上 */
  .center-wrap{
    position:fixed; inset:0; display:grid; place-items:center; padding:24px;
    z-index:1;
  }

  .form{
    position:relative; width:320px; padding:28px;
    display:flex; flex-direction:column; gap:16px;
    background: rgba(0,0,0,.6);
    border-radius:15px; backdrop-filter: blur(10px);
    box-shadow:
      rgba(0,0,0,.6) 0 2px 4px,
      rgba(0,0,0,.5) 0 7px 13px -3px,
      rgba(0,0,0,.3) 0 -3px 0 inset;
    animation: form-in .5s ease;
  }
  @keyframes form-in{ from{opacity:0; transform:translateY(8px)} to{opacity:1; transform:translateY(0)} }

  .input{
    padding:12px; border-radius:15px;
    background: rgba(0,0,0,.4);
    border:2px solid rgba(255,255,255,.2);
    color:#fff; transition:.25s;
    box-shadow:
      0 2px 4px rgba(0,0,0,.5),
      0 7px 13px rgba(0,0,0,.3),
      inset 0 -3px 0 rgba(0,0,0,.2);
  }
  .input::placeholder{color:rgba(255,255,255,.7)}
  .input:focus,.input:hover{
    outline:none; border-color:rgba(255,255,255,.4); background:rgba(0,0,0,.55);
    transform: translateZ(0) scale(1.02);
  }

  button{
    padding:10px 20px; border:none; border-radius:10px;
    background: rgba(96,165,250,.95); color:#fff; font-size:16px; cursor:pointer;
    transition:.25s; box-shadow: rgba(0,0,0,.5) 0 2px 4px, rgba(0,0,0,.4) 0 7px 13px -3px;
  }
  button:hover{ transform:translateY(-1px); background:rgba(147,197,253,1) }
  button:disabled{opacity:.6; cursor:not-allowed}

  h1{ text-align:center; font-size:1.25rem; letter-spacing:.5px; color:#60a5fa; margin:0 }
  p{ text-align:center; font-size:.88rem; color:#a9b0bd; margin:0 0 6px }
</style>
</head>
<body>

  <!-- 极光背景 -->
  <div id="aurora-bg" aria-hidden="true"></div>

  <!-- 登录表单（居中） -->
  <div class="center-wrap">
    <form class="form" id="loginForm">
      <h1>Qyen Vision 登录</h1>
      <p>欢迎回来，探索你的 AI 世界</p>

      <input id="username" class="input" type="text" placeholder="用户名" required />
      <input id="password" class="input" type="password" placeholder="密码" required />
      <button id="loginBtn" type="submit">登录</button>

      <div class="text-center text-sm mt-1">
        <a href="#" class="text-blue-400/90 hover:underline">忘记密码？</a>
      </div>
    </form>
  </div>

  <!-- 已登录直达 -->
  <script>
    if (localStorage.getItem('isLoggedIn') === 'true') {
      location.href = 'qyen.html';
    }
  </script>

  <!-- 登录逻辑（把 N8N_WEBHOOK_URL 改成你的生产地址） -->
  <script>
    const N8N_WEBHOOK_URL = 'https://n8n-kjycwasd.us-east-1.clawcloudrun.com/webhook/login';

    const form = document.getElementById('loginForm');
    const btn  = document.getElementById('loginBtn');

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      btn.disabled = true; btn.textContent = '验证中...';

      const username = document.getElementById('username').value.trim();
      const password = document.getElementById('password').value.trim();

      try{
        const res = await fetch(N8N_WEBHOOK_URL, {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ username, password })
        });
        const data = await res.json();
        if (data.success) {
          localStorage.setItem('isLoggedIn','true');
          btn.textContent = '登录成功';
          location.href = 'qyen.html';
        } else {
          btn.disabled = false; btn.textContent = '登录';
          alert('❌ 用户名或密码错误');
        }
      }catch(err){
        btn.disabled = false; btn.textContent = '登录';
        alert('❌ 登录接口出错：' + err.message);
      }
    });
  </script>

  <!-- Aurora 背景（OGL，自动兼容 WebGL2 / WebGL1） -->
  <script type="module">
    import { Renderer, Program, Mesh, Color, Triangle } from 'https://unpkg.com/ogl@0.0.105/dist/ogl.mjs';

    // 参数（等价于 <Aurora .../>）
    const PARAMS = {
      colorStops: ["#3A29FF", "#FF94B4", "#FF3232"],
      blend: 0.5,
      amplitude: 1.0,
      speed: 0.5
    };

    // WebGL2 着色器
    const VERT300 = `#version 300 es
    in vec2 position;
    void main(){ gl_Position = vec4(position, 0.0, 1.0); }`;

    const FRAG300 = `#version 300 es
    precision highp float;
    uniform float uTime;
    uniform float uAmplitude;
    uniform vec3  uColorStops[3];
    uniform vec2  uResolution;
    uniform float uBlend;
    out vec4 fragColor;
    vec3 permute(vec3 x){ return mod(((x*34.0)+1.0)*x, 289.0); }
    float snoise(vec2 v){
      const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);
      vec2 i=floor(v+dot(v,C.yy)); vec2 x0=v-i+dot(i,C.xx);
      vec2 i1=(x0.x>x0.y)?vec2(1.0,0.0):vec2(0.0,1.0);
      vec4 x12=x0.xyxy+C.xxzz; x12.xy-=i1; i=mod(i,289.0);
      vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));
      vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0); m*=m; m*=m;
      vec3 x=2.0*fract(p* C.www)-1.0; vec3 h=abs(x)-0.5; vec3 ox=floor(x+0.5); vec3 a0=x-ox;
      m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);
      vec3 g; g.x=a0.x*x0.x+h.x*x0.y; g.yz=a0.yz*x12.xz+h.yz*x12.yw;
      return 130.0*dot(m,g);
    }
    struct ColorStop{ vec3 color; float position; };
    #define COLOR_RAMP(colors, factor, finalColor) { \
      int index=0; for(int i=0;i<2;i++){ ColorStop cc=colors[i]; bool ok=cc.position<=factor; index=int(mix(float(index),float(i),float(ok))); } \
      ColorStop c0=colors[index]; ColorStop c1=colors[index+1]; \
      float range=c1.position-c0.position; float k=(factor-c0.position)/range; \
      finalColor=mix(c0.color,c1.color,k); }
    void main(){
      vec2 uv=gl_FragCoord.xy/uResolution;
      ColorStop colors[3];
      colors[0]=ColorStop(uColorStops[0],0.0);
      colors[1]=ColorStop(uColorStops[1],0.5);
      colors[2]=ColorStop(uColorStops[2],1.0);
      vec3 rampColor; COLOR_RAMP(colors, uv.x, rampColor);
      float height=snoise(vec2(uv.x*2.0+uTime*0.1, uTime*0.25))*0.5*uAmplitude;
      height=exp(height); height=(uv.y*2.0-height+0.2);
      float intensity=0.6*height;
      float mid=0.20;
      float A=smoothstep(mid-uBlend*0.5, mid+uBlend*0.5, intensity);
      vec3 col=intensity*rampColor;
      fragColor=vec4(col*A, A);
    }`;

    // WebGL1 兼容版着色器
    const VERT100 = `
    attribute vec2 position;
    void main(){ gl_Position = vec4(position, 0.0, 1.0); }`;

    const FRAG100 = `
    precision highp float;
    uniform float uTime;
    uniform float uAmplitude;
    uniform vec3  uColorStops[3];
    uniform vec2  uResolution;
    uniform float uBlend;
    vec3 permute(vec3 x){ return mod(((x*34.0)+1.0)*x, 289.0); }
    float snoise(vec2 v){
      const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);
      vec2 i=floor(v+dot(v,C.yy)); vec2 x0=v-i+dot(i,C.xx);
      vec2 i1=(x0.x>x0.y)?vec2(1.0,0.0):vec2(0.0,1.0);
      vec4 x12=x0.xyxy+C.xxzz; x12.xy-=i1; i=mod(i,289.0);
      vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));
      vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0); m*=m; m*=m;
      vec3 x=2.0*fract(p* C.www)-1.0; vec3 h=abs(x)-0.5; vec3 ox=floor(x+0.5); vec3 a0=x-ox;
      m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);
      vec3 g; g.x=a0.x*x0.x+h.x*x0.y; g.yz=a0.yz*x12.xz+h.yz*x12.yw;
      return 130.0*dot(m,g);
    }
    struct ColorStop{ vec3 color; float position; };
    #define COLOR_RAMP(colors, factor, finalColor) { \
      int index=0; for(int i=0;i<2;i++){ ColorStop cc=colors[i]; bool ok=cc.position<=factor; index=int(mix(float(index),float(i),float(ok))); } \
      ColorStop c0=colors[index]; ColorStop c1=colors[index+1]; \
      float range=c1.position-c0.position; float k=(factor-c0.position)/range; \
      finalColor=mix(c0.color,c1.color,k); }
    void main(){
      vec2 uv=gl_FragCoord.xy/uResolution;
      ColorStop colors[3];
      colors[0]=ColorStop(uColorStops[0],0.0);
      colors[1]=ColorStop(uColorStops[1],0.5);
      colors[2]=ColorStop(uColorStops[2],1.0);
      vec3 rampColor; COLOR_RAMP(colors, uv.x, rampColor);
      float height=snoise(vec2(uv.x*2.0+uTime*0.1, uTime*0.25))*0.5*uAmplitude;
      height=exp(height); height=(uv.y*2.0-height+0.2);
      float intensity=0.6*height;
      float mid=0.20;
      float A=smoothstep(mid-uBlend*0.5, mid+uBlend*0.5, intensity);
      vec3 col=intensity*rampColor;
      gl_FragColor=vec4(col*A, A);
    }`;

    // 创建上下文：优先 WebGL2，失败再 WebGL1
    const mount = document.getElementById('aurora-bg');
    const canvas = document.createElement('canvas');
    canvas.style.cssText = 'width:100%;height:100%;display:block;background:transparent';
    mount.appendChild(canvas);

    let gl = canvas.getContext('webgl2', { alpha:true, antialias:true, premultipliedAlpha:true });
    let isWebGL2 = !!gl;

    if (!gl) {
      gl = canvas.getContext('webgl', { alpha:true, antialias:true, premultipliedAlpha:true })
        || canvas.getContext('experimental-webgl', { alpha:true, antialias:true, premultipliedAlpha:true });
      isWebGL2 = false;
    }

    if (!gl) {
      console.warn('WebGL 不可用，降级为静态背景。');
      mount.style.background = 'radial-gradient(1200px 800px at 70% 0%, rgba(58,41,255,.45), rgba(0,0,0,0))';
    } else {
      const renderer = new Renderer({ canvas, context: gl, dpr: Math.min(devicePixelRatio||1, 2) });
      const ogl = renderer.gl;
      ogl.clearColor(0,0,0,0);
      ogl.enable(ogl.BLEND);
      ogl.blendFunc(ogl.ONE, ogl.ONE_MINUS_SRC_ALPHA);

      // 全屏三角形
      const geometry = new Triangle(ogl);
      if (geometry.attributes.uv) delete geometry.attributes.uv;

      const toRGB = (hex) => {
        const c = new Color(hex);
        return [c.r, c.g, c.b];
      };

      const program = new Program(ogl, {
        vertex:  isWebGL2 ? VERT300 : VERT100,
        fragment:isWebGL2 ? FRAG300 : FRAG100,
        uniforms: {
          uTime:       { value: 0 },
          uAmplitude:  { value: PARAMS.amplitude },
          uBlend:      { value: PARAMS.blend },
          uResolution: { value: [1, 1] },
          uColorStops: { value: PARAMS.colorStops.map(toRGB) }
        },
        transparent: true,
        depthTest: false
      });

      const mesh = new Mesh(ogl, { geometry, program });

      function resize(){
        const w = mount.clientWidth || innerWidth;
        const h = mount.clientHeight || innerHeight;
        renderer.setSize(w, h);
        program.uniforms.uResolution.value = [w, h];
      }
      resize();
      addEventListener('resize', resize);

      let t0 = performance.now();
      function raf(now){
        const dt = (now - t0) / 1000; t0 = now;
        program.uniforms.uTime.value += dt * (PARAMS.speed || 0.5);
        program.uniforms.uAmplitude.value = PARAMS.amplitude;
        program.uniforms.uBlend.value     = PARAMS.blend;
        program.uniforms.uColorStops.value = PARAMS.colorStops.map(toRGB);
        renderer.render({ scene: mesh });
        requestAnimationFrame(raf);
      }
      requestAnimationFrame(raf);
    }
  </script>
</body>
</html>

